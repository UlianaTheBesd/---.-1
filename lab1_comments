#!/bin/bash
echo "Введите путь до папки: "
read path_to_log

if [ ! -d "$path_to_log" ]; then
    echo "Ошибка: Папка $path_to_log не существует"
    exit 1
fi

# [ ] = вызов утилиты test. Утилита проверяет условие внутри скобок , и возвращает либо 0 (true), либо 1 (false) (в Linux 0 и 1 наоборот). Утилита работает со строками, файлами и числами, но числа сравниваются специальными словами (-eq, -lt, -gt и тому подобное).
# ! = логическое НЕ.
# -d = directory. Проверяет то, что папка в скобках (почему в имя папки скобках - написано в рассуждениях ниже).
# ; then - так мы пишем “:”.
# fi - это if в обратную сторону. Означает завершение условной конструкции в Bash.

amount_of_log=$(du -sk "$path_to_log" | awk '{print $1}')

# $. Используется для получения значения переменной.
# du = disk usage. Показывает текстом ("250M" например) числовой размер папки. Стандартный вывод du:
#123456  /var/log
# -sh - два флага = summarize+human-readable. (1) Summarize говорит du и df показать суммарный размер (обычно выводит кол-во блоков, каждый из которых занимает 1024 байт), а не построчно выводить каждый размер папок/файлов на пути. (2) Human-readable форматирует размер, добавляя буквы K, M, G.
# -k = kilobytes? Помогает вывести значение в килобайты.
# “...” - кавычки для целостности. Мы используем это для переменной, чтобы она передалась полностью, а не отдельными словами, если переменная будет записана, например, через пробел.
# | = конвейер. Синтаксис: команда, отправляющая результат на стандартный вывод | (перехват вывода -> смена на стандартный вввод для другой команды) другая команда.
# bc = basic calculator. Синтаксис: echo "10 / 3" |  bc. Нужен для обработки математических операций. Перехватывает из вывода echo строку, и обрабатывает её.
# awk = Aho, Weinberger, Kernighan (создатели). Читает строку и разделяет её (по пробелам обычно). Далее можно обратиться к каждой колонке через $1, $2... (строка целиком $0, если потребуется). Синтаксис: команда | awk '{print $1}' - где: (1) скобки - защита данных при передаче awk, (2) {print …} - команда для awk, (3) $1 - обращение к колонке.

amount_full_way=$(df -k "$path_to_log" | awk 'NR==2 {print $2}')

# NR = Number of Record. Синтаксис: NR==2 (где 2 - номер строки). И в NR, и в print (команды awk)  мы используем номера начиная с 1, а не с 0. 
# df = disk free. Показывает общий числовой размер диска (в нашем случае в КБ). Стандартный вывод df:
#Filesystem     1K-blocks      Used Available Use% Mounted on
#/dev/sda1       10485760   5242880   5242880  50% /

percent_log=$(echo "scale=2; ($amount_of_log / $amount_full_way) * 100" | bc)

# scale=2 - команда для bc. Вывод n знаков после запятой, в нашем случае 2 (bc по умолчанию работает с целыми числами, а scale отдаёт десятичные).
# bc, в данном случае, принимает из echo строку, где первая часть - scale, а вторая - математическое выражение.

echo "Введите процент занятости: "
read percent_N

# добавила счётчик counter, чтобы именовать архивы по-разному (ниже).

if (( $(echo "$percent_log < $percent_N" | bc -l) )); then

# -lt = less than. “<”.
# (( )) - в отличие от одинарных скобок ( ), которые используют для группировки команд, или квадратных [ ], которые нужны для логических выражений, в (( )) выполняются только математические операции.
# Почему if работает и с (( )), и с [ ]?
# if смотрит на возврат команды в скобках. Если пришло 0 (true), которое может прийти и от test ([ ]), и от обычной команды (( )) - значит if воспринимает это как true. С false проще - любое число не являющееся 0 (преим. больше 0) - false.
# -l = library. Позволяет bc работать с десятичными дробями и сравнивать их, возвращая 0 (true) или 1 (false). Этот способ лучше, чем [ ... -lt ... ], который был прежде, из-за разрешения работы с дробными числами.

	echo "Сколько старых файлов архивировать:"
  read old_files_M
  mkdir -p "$HOME/backup"

# mkdir = make directory. Нужно, чтобы не возникало ошибок. Также прописан флаг “-p” (parents) - который создаст все родительские папки до /backup, а также не выдаст ошибку уже при существовании папки.
# $HOME - путь к домашней директории текущего пользователя (например, /home/uliana).
# Почему просто не /backup? -> В Linux на /backup часто нет прав у обычного пользователя, поэтому нужно будет работать через sudo. Из-за этого будет проще писать архивы сразу в домашнюю папку.

  archive="$HOME/backup/archive_$(date +%Y%m%d_%H%M%S).tar.gz"
  tar -czvf "$archive" -C "$path_to_log" $(find "$path_to_log" -type f | sort | head -n "$old_files_M")

# tar (-czvf) = Tape Archiver. Синтаксис: tar (флаги) (путь куда архивировать). Команда для архивации файлов. Флаги: (1) “-c” = create, создать новый архив; (2) “-z” = gzip, сжатие архива при помощи утилиты gzip (в задании написано “tar+gzip”); (3) “-v” = verbose, показать список добавленных файлов; (4) “-f” = file, куда сохранить (далее после tar пишем место, куда сохранить - файл с .tar.gz).
# -C = Change. Позволяет tar сменить директорию перед архивированием, т.е. зайти в другую (указанную) папку и уже оттуда работать с файлами. В архив записываются относительные пути файлов (относительно этой новой папки), а не оригинальный путь файлов.
# find. Синтаксис: find (путь к папке). Утилита находит все файлы в папке.
# -type f флаг. Ограничивает поиск только файлами (f от file), чтобы случайно не затронуть папки и т.п.
# sort. Утилита сортирует список файлов. По умолчанию список разделен переносом строки.
# head -n "$old_files_M" (-n флаг). Синтаксис: head (file). Утилита указывает в начало списка. Флаг -n указывает, сколько строк нужно взять с начала списка. Используем переменную $old_files_M, чтобы взять определённое количество файлов.

fi

# Запуск:
# chmod +x lab1.sh
# ./lab1.sh
